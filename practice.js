/* 코어 자바스크립트 연습장 */

1-1 데이터 타입
JS의 데이터 타입은 크게 두 가지가 있다.
1. 기본형 : 숫자, 문자열, 불리언, null undefined, 심볼(ES6 추가)
2. 참조형 : 객체, 배열, 함수, 날짜, 정규표현식, ES6 추가-> Map, WeakMap, Set, WeakSet
기본형과 참조형을 구분하는 기준 ? 할당이나 연산시 -> 기본형은 복제, 참조형은 참조형
※엄밀히 말하면 둘다 복제를 하지만 기본형은 값이 담긴 주솟값을 바로 복제, 참조형은 값이
  담긴 주솟값들로 이루어진 묶음을 가리키는 주솟값을 복제한다는게 차이점
1-2 데이터 타입에 관한 배경지식
1byte = 8개의 비트 = 256개의 값 표현가능(메모리의 효율을 증가시키기 위해 byte를 사용)
위 방법은 메모리가 한정적이였던 과거에 필연적인 선택이였음
근데 요즘은? 메모리가 과거에 비해 월등히 커짐.
따라서 JS는 상대적으로 메모리 관리에 대한 압박에서 자유로워짐.
숫자의 경우 구분없이 8byte 를 확보한다
한편 각 비트는 고유한 식별자를 지닌다. 바이트 역시 시작하는 비트의 식별자로 위치를 파악
바이트 단위의 식별자, 더 정확하게는 메모리 주솟값을 통해 서로 구분하고 연결할 수 있다.
변수 = 변할 수 있는 수(꼭 숫자를 말하는건 아님)
식별자 = 어떤 데이터를 식별하는 데 사용하는 이름, 즉 변수명이다.
1-3 변수 선언과 데이터 할당
변수 선언의 동작원리 => var a ==> 변할 수 있는 데이터를 만든다. 이 데이터의 식별자=a
변수의 정확한 이해 = 변경 가능한 데이터가 담길 수 있는 공간
컴퓨터가 'var a;' 란 명령을 받아 메모리 영역에서 어떤 작업을 수행하는지를 표현
ⓐ메모리에서 비어있는 공간 하나를 확보한다. (그림 1-3에선 임의로 1003번)
ⓑ이 공간의 이름(식별자)을 a라고 지정합니다. 여기까지가 변수 선언 과정
ⓒ이후에 사용자가 a에 접근하고자 하면 컴퓨터는 메모리에서 a라는 이름을 가진 주소를 검색
  하여 해당 공간에 담긴 데이터를 반환할 것이다.
다음은 'var a = 'abc'', 즉 변수 선언에 + 할당을 했을 때의 동작원리
※데이터를 저장하기 위한 별도의 메모리 공간을 다시 확보해서 문자열 'abc'를 저장하고,
  그 주소를 변수영역에 저장하는 식으로 이뤄집니다.
변수 선언 + 데이터 할당 시 동작(그림1-4)
ⓐ변수 영역에서 빈 공간(주소=@1003)을 확보한다
ⓑ확보한 공간의 이름(식별자)를 a로 지정한다.
ⓒ데이터 영역의 빈 공간(주소=@5004)에 문자열 'abc'를 저장한다.
ⓓ변수 영역에서 a라는 식별자를 검색한다(주소=@1003)
ⓔ앞서 저장한 문자열의 주소(주소=@5004)를 @1003의 공간에 대입한다
왜 변수 영역(@1003)에 직접 대입안하고 한 단계를 더 거치냐?
==> 데이터 변환을 자유롭게 할 수 있게 함과 동시에 메모리를 더욱 효율적으로 관리하기 위함
이게 뭔소리냐? JS는 숫자형 데이터에 대해 64비트(8바이트)의 공간을 확보한다고 했지!?
반면 문자열은 특별히 정해진 규격이 없어.
근데 만약 미리 확보한 공간 내에서만 데이터 변환을 할 수 있다면? 변환한 데이터를 다시
저장하려면 '확보된 공간을 변환된 데이터의 크기에 맞게 늘리는 작업'이 선행돼야하지?
이게 만약 중간에 있는 데이터를 늘려야하는 상황이라면? 뒤에있는 데이터를 옮기고 다시 연결하고
어쨋든 컴퓨터가 처리하는 연산이 ㅈㄴ 많아짐. 결국 효율적으로 문자열 데이터의 변환을 처리하려면?
변수와 데이터를 별도의 공간에 나누어 저장하는 것이 최적이다 ~ 이말이야
ex)문자열 'abc'의 마지막에 'def'를 추가(그림1-5)
ⓐ'abc'가 할당된 공간에 'abcdef'를 할당하는 것이 아니라 새로운 공간에 'abcdef'를 할당
ⓑ'abcdef'를 할당한 새로운 공간의 주소를 변수 공간에 연결한다.
변수 영역과 데이터 영역을 분리하는것의 또 다른 장점은 중복의 효율
만약 500개의 변수에 모두 숫자 5를 할당한다면?
변수와 데이터를 분리하지않으면 => 500개의 변수공간을 확보하고 각각 5를 할당=(500*8=4000바이트)
변수와 데이터를 분리한다면 => 한 공간에 5를 할당하고 500개 변수 모두 그 주소를 지정=주소가 2바이트라 가정하면 (500 * 2 +8=1008 바이트)
1-4 기본형 데이터와 참조형 데이터
변수와 상수의 차이? = 변수는 변경가능, 상수는 변경불가
변수와 상수를 구분짓는 변경 가능성의 대상 = 변수 영역 메모리(한번 데이터 할당이 일어난 변수 공간에 다른 데이터를 재할당 할 수 있는지 여부)
불변성의 여부를 구분할 때의 변경 가능성의 대상 = 데이터 영역 메모리
기본형 데이터인 숫자, 문자열, boolean, null, undefined, Symbol은 불변값이다.
숫자와 문자열을 예로 불변성의 개념을 알아보자.
/*
예제1-3 코드
var a = 'abc';
a = a + 'def';

var b = 5;
var c = 5;
b = 7;
*/
위 코드에서 변수 a에 문자열 'abc'를 할당했다가 뒤에 'def'를 추가하면 기존의 'abc'데이터가
'abcdef'로 바뀌는것이 아니라 새로운 문자열 'abcdef'를 만들어 그 주소를 변수 a에 저장. => 'abc'와 'abcdef'는 완전 별개의 데이터
변수 b에 5를 할당. 그러면 컴퓨터는 일단 데이터 영역에서 5를 찾고 없으면 데이터 공간에 5를 만들어 저장 후 그 주소를 b에 저장
변수 c에서도 5를 할당. 그럼 앞에서 만들어 놓은 5 데이터영역이 있기 때문에, 그 주소를 재활용
변수 b를 7로 변경. 기존된 저장된 5를 7로 바꾸는게 아니라 7을 찾고 없으면 새로 만들어 그 주소를 할당
결국 5와 7, 'abc', 'abcdef'는 변할 수 없는 불변값이다!!
변경은 새로 만드는 동작을 통해서만 이뤄집니다. 이게 바로 불변값의 성질입니다.(유일한 경우 = 가비지 컬렉팅)
참조형 데이터는 몇개의 예외를 제외하곤 다 가변값이다.
/*
예제 1-4 코드
var obj1 = {
    a: 1;
    b: 'bbb'
};
*/
ⓐ컴퓨터는 우선 변수 영역의 빈 공간(@1002)를 확보하고, 그 주소의 이름을 obj1로 지정
ⓑ임의의 데이터 저장 공간(@5001)에 데이터를 자장하려고 보니 여러개의 프로퍼티로 이뤄진 데이터 그룹이다,
  이 그룹의 내부 프로퍼티를 저장하기 위해 별도의 변수 영역을 마련하고, 그 영역의 주소(@7103~?)를 @5001에 저장
ⓒ@7103 및 @7104에 각각 a와 b라는 프로퍼티 이름을 저장한다
ⓓ데이터 영역에서 숫자 1을 검색하고 없으므로 @5003에 저장하고, 이 주솟값을 @7103에 저장
  마찬가지로 'bbb' 역시 없으므로 @5004에 저장하고, 이 주소를 @7104에 저장한다.
기본형 데이터와의 차이는 '객체의 변수(프로퍼티) 영역'이 별도로 존재한다는 점.
데이터 영역은 불변값이지만 객체의 변수공간은 언제든지 다른 공간을 할당가능하다.
==> 따라서 참조형은 불변값이 아니다 라고 하는 것.
1-4 코드에서 obj.a = 2;을 실행하면 데이터 영역에서 2를 찾고 없으면 새로 만들어 그 주소를 a변수 값에 저장

